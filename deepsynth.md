# DeepSynth

Nat Fijalkow on Machine Learning Guided Program Synthesis

## Intro
* syntactically restricting the space of programs
  * Sketching [Solar-Lezama]
  * Programs generated by a context-free grammar (this is very useful for the
    search procedure)
* Reduction to SAT (used in subroutine, with an assumption that this can be done
  efficiently, so correctness of the program can be checked very efficiently)
* OGIS: oracle-guided inductive synthesis
* Program is an expression with input variables in the leaves
* [SyGUS CACM paper]
* Three items
  1. Specification (input/output)
  2. Program space (given by a CFG)
  3. Search algorithms
## Applications
  * TF-coder
## Search algorithms
Three approaches
  1. Enumerative search
	 	enumerate all programs in some well chosen order, and check them one by one
		This is already very powerful for current state of the art
  2. Deductive search
     Decide what is the top instruction and decompose your question into
     subquestions for the arguments for this instruction.
  3. Constraint solving
		Correctness of a program can be stated as a SAT formula. 
     You start with some program you check for correctness. You get a
     counterexample and a solver gives you a program satisfying all the examples
     you have so far. 
		 [DeepCoder, Balog et al]

Probabilistic context-free grammar: there is a probability for applying every
construct.
So now you learn Probabilistic CFG, and then do the enumeration.
One can also do sampling. Actually one can find best CFG for sampling, but
sampling is rather stupid as it may propose the same solution many times.
Enumeration is much more interesting but it is much harder to implement in CFG.

